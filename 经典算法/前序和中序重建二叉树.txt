#include <iostream>
#include <cstring>
#include<stdio.h>
#include<vector>
#include<stack>
#include<algorithm>
#include<string>
#include<string.h>
#include<set>
#include<list>
#include<map>
#include<deque>
#include<ostream>
using namespace std;
/**
 * Description:前序和中序重建二叉树
 * Blog: www.qiuchengjia.cn
 * Data: 2017-5-16
 * Author: colin
 */
struct TreeNode{
    TreeNode * left = NULL;
    TreeNode * right = NULL;
    char value;
};
TreeNode * buildTree(char * preOrder , int start , char * inOrder , int end , int length){
    if(preOrder == NULL || (sizeof(preOrder)/sizeof(preOrder[0])) == 0
       || inOrder == NULL || (sizeof(inOrder)/sizeof(inOrder[0])) == 0 || length <= 0)
        return NULL;
     //建立子树根节点
    char value = preOrder[start];
    TreeNode * node = new TreeNode;
    node->value = value;

    //递归终止条件：子树只有一个节点
    if(length == 1)
        return node;
    int i = 0;
    while(i < length){
        if(value == inOrder[end - i]){
            break;
        }
        i++;
    }
    node->left = buildTree(preOrder , start + 1 , inOrder , end - i - 1 , length - i - 1);
    node->right = buildTree(preOrder , start + length - i , inOrder , end ,i);
    return node;
}
void ergodicTree(TreeNode * root){
    if(root == NULL)
        return;
    printf("%c ," , root->value);
    ergodicTree(root->left);
    ergodicTree(root->right);
}
int main(){
    char preOrder[] = {'a', 'b', 'd', 'c', 'e', 'f'};
    char inOrder[] = {'d', 'b', 'a', 'e', 'c', 'f'};
    TreeNode * root = buildTree(preOrder , 0 , inOrder ,
                                (sizeof(inOrder)/sizeof(inOrder[0])) - 1 ,
                                (sizeof(inOrder)/sizeof(inOrder[0])));
    ergodicTree(root);
    return 0;
}


